<?xml version="1.0" encoding="utf-8"?>
<!--
 - Copyright 2021-2021 SanteSuite Contributors (See NOTICE.md for full copyright notices)
 - Copyright (C) 2019 - 2021, Fyfe Software Inc. and the SanteSuite Contributors
 - Portions Copyright (C) 2015-2018 Mohawk College of Applied Arts and Technology
 -
 - Licensed under the Apache License, Version 2.0 (the "License"); you
 - may not use this file except in compliance with the License. You may
 - obtain a copy of the License at
 -
 - http://www.apache.org/licenses/LICENSE-2.0
 -
 - Unless required by applicable law or agreed to in writing, software
 - distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 - WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 - License for the specific language governing permissions and limitations under
 - the License.
 -
 - User: fyfej
 - Date: 2021-10-28
 -->

<!--
  SanteDB Match Configuration XML to HTML XSLT

  This XSLT will accept an input match configuration from SanteDB's matching engine and will render it as an HTML
  file which can then be used to create a report of the settings which were used on the matching engine.

  1.0 Notes:
     * The XSLT uses the Microsoft XSL engine extensions which allow for scripts to be run - these scripts are
       used to keep track of state (since XSL 1.0 lacks this). An equivalent XALAN (Java) function is provided
     * The XSLT parameter jsonConfig can be empty however the mermaid graphs won't work - so you should pass a JSON representation
       (generated by SanteDB) into jsonConfig. If you do not set this variable then the mermaid graphs are not rendered.

  2.0 Running

  2.1 Running from Visual Studio

  To run this file as is, you will need an XSLT engine which uses the .NET Framework XslCompiledTransform and allows scripts to
  run. Visual Studio Professional is a good tool for this:

      1. Open this file in Visual Studio
      2. In the Properties window set the {input} property to the configuration file you wish to render
      3. From the {XML} menu select {Start XSLT Without Debugging}

  2.2 Running from .NET Console Application

  You can also execute this file by writing a small .NET Core application:

  // Run the XSLT
  var xsl = new XslCompiledTransform();
  xsl.Load("MatchConfiguration.xslt", new XsltSettings() { EnableScript = true }, null);

  // Option 1: Load the XML File and apply
  xsl.Transform("path-to-config.xml", "path-to-output.html");

  // Option 2: Use the SanteDB.Matcher NUGET package to load the configuration
  // This is how you can get the Mermaid JS stuff rendering
  using (var fs = File.OpenRead("configuration.xml"))
  {
      var configuration = MatchConfiguration.Load(fs);
      using (var ms = new MemoryStream())
      {
          // Save configuration to XML
          configuration.Save(ms);
          ms.Seek(0, SeekOrigin.Begin);

          // Now read as XML (for XSLT)
          using (var xr = XmlReader.Create(ms))
          {
              using (var xw = XmlWriter.Create(RestOperationContext.Current.OutgoingResponse.OutputStream))
              {
                  // We are running with JSON Configuration because we want those pretty graphs
                  var args = new XsltArgumentList();
                  args.AddParam("jsonConfig", "http://santedb.org/matcher", JsonConvert.SerializeObject((object)configuration));
                  this.m_transform.Transform(xr, args, xw);
              }
          }
      }
  }

  2.3 Running from Java

  To run this in Java you will need to use the Apache Xalan-J library, and follow these steps:

      1. Comment the msxsl:script element (as this won't work in Xalan)
      2. Un-comment the <xalan:component> element
      3. (fingers crossed) your XSLT should run in an equivalent manner

   You could also modify this script to run in Saxon based XSLT processors, however you would need to convert the <xalan:component> functions
   to Java and expose them as extended functions (minor effort)
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt" exclude-result-prefixes="msxsl m"
                xmlns:m="http://santedb.org/matcher"
                xmlns:f="http://santedb.org/xsl-functions"
                xmlns="http://www.w3.org/1999/xhtml"
                xmlns:h="http://www.w3.org/1999/xhtml"

>

  <xsl:output method="html" indent="yes" />

  <!-- Argument: jsonConfig
        Set this variable to a JSON string of the configuration which this XSLT is being applied against -
        then the mermaid JS graphs will be rendered
  -->
  <xsl:param name="m:jsonConfig" />

  <!-- MSXSL Script to assist in rendering pseudocode graphs -->
  <msxsl:script implements-prefix="f" language="C#">
    <![CDATA[

    bool isMeasured = false;
    public void setMeasured() {
      isMeasured = true;
    }
    public void resetMeasured() {
      isMeasured = false;
    }
    public bool getMeasured() {
      return isMeasured;
    }
    ]]>
  </msxsl:script>

  <!-- Equivalent script as above only written in JavaScript
  <xalan:component xmlns:xalan="http://xml.apache.org/xalan" prefix="f" functions="setMeasured resetMeasured getMeasured">
    <xalan:script lang="javascript">
      <![CDATA[
      var isMeasured = false;
      function setMeasured() {
        isMeasured = true;
      }
      function resetMeasured() {
        isMeasured = false;
      }
      function getMeasured() {
        return isMeasured;
      }
      ]]>
    </xalan:script>
  </xalan:component>
  -->
  <!--
    Template: MatchConfiguration
    The <MatchConfiguration> element is the root of the SanteDB match configuration object
  -->
  <xsl:template match="m:MatchConfiguration">

    <!-- HACK: If we write JavaScript inline in XSLT the value is escaped - by storing this as a variable it allows us to bypass
                escaping of the output script -->
    <xsl:variable name="mermaidScript">
      var configuration = <xsl:value-of select="$m:jsonConfig" />;

      <!-- Minified script to render the MermaidJS : source: https://github.com/santedb/santedb-match/blob/38515d2de3ab92ca38fc44c284c17ca42d9709ac/SanteDB.Matcher/Definition/MatchConfigurationMetadata.cs-->
      <![CDATA[
function renderBlockingSubgraph(e,a,r){var n="subgraph Blocking[\"<i class='fa fa-database'></i> Blocking\"]\ndirection TB\n";for(var i in e.blocking)if(void 0===r||r===i){var t=e.blocking[i];if(n+=0==i||void 0!==r?`DB[("${e.target.map(e=>e.resource).join("|")}")]==>`:"DB==>",n+=" ",1==t.filter.length)a&&t.filter[0].when&&""!=t.filter[0].when&&(n+=`B${i}W0{{"<i class='fa fa-question'></i> $input.${t.filter[0].when}"}}\nB${i}W0--\x3e|"[null]"|BJOIN\nB${i}W0--\x3e|"[not null]"| `),n+=`B${i}F0["<i class='fa fa-filter'></i> ${t.filter[0].expression.split("=")[0]}"]\n`,n+=`B${i}F${t.filter.length-1}--\x3e`;else{n+=`Block${i}\nsubgraph Block${i}\ndirection TB\n`;for(var s=0;s<t.filter.length;s++){var l=t.filter[s];a&&t.filter[s].when&&""!=t.filter[s].when&&(n+=`B${i}W${s}{{"<i class='fa fa-question'></i> $input.${t.filter[s].when}"}}\n`,s<t.filter.length-1?n+=`B${i}W${s}--\x3e|"[null]"|B${i}W${s+1}\n`:n+=`B${i}W${s}--\x3e|"[null]"|B${i}RET(("results"))\n`,n+=`B${i}W${s}--\x3e|"[not null]"| `),n+=`B${i}F${s}["<i class='fa fa-filter'></i> ${l.expression.split("=")[0]}"]`,s==t.filter.length-1&&(n+="\n",a&&(n+=`B${i}F${s}--\x3eB${i}RET\n`)),s<t.filter.length-1&&(n+="--\x3e",n+='|"intersect"| ',s<t.filter.length-2&&(n+=a?`B${i}${t.filter[s+1].when&&""!=t.filter[s+1].when?"W":"F"}${s+1}\n`:`B${i}F${s+1}\n`))}n+=`end\nBlock${i}--\x3e`}n+=`|${"AndAlso"==t.op?"intersect":"union"}| `,n+="BJOIN",n+=0==i?"([\"<i class='fa fa-code-branch'></i> Collect Blocked Records\"])\n":"\n"}return n+="end\n"}function renderOpCode(e){switch(e){case"LessThan":case 1:return"<";case"LessThanOrEqual":case 2:return"<=";case"GreaterThan":case 3:return">";case"GreaterThanOrEqual":case 4:return">";case"NotEqual":case 5:return"!=";case"AndAlso":case 6:return"&&";case"OrElse":case 7:return"||";default:return"=="}}function renderAssertionBlock(e,a,r){var n="";for(var i in r.transform){var t=r.transform[i];n+=`${e}--\x3e${a}T${i}[["<i class='fa fa-code'></i> ${`${t.name}(${t.args.join(",")})`}"]]\n`,e=`${a}T${i}`}if(0==r.assert.length)r.value?n+=`${e}--\x3e${a}OUT{{"<i class='fa fa-question'></i> ${renderOpCode(r.op)} ${r.value}"}}\n`:n+=`${e}--\x3e${a}OUT{{"<i class='fa fa-question'></i> ${renderOpCode(r.op)}"}}\n`;else for(var s in r.assert){n+=renderAssertionBlock(e,`${a}A${s}`,r.assert[s]),n+=`${a}A${s}OUT--\x3e|"[true]"| ${a}OUT{{"<i class='fa fa-question'></i> ${renderOpCode(r.op)}"}}\n`}return n}function renderScoringSubgraph(e,a,r){e.target[0].resource;var n=`subgraph Scoring["<i class='fa fa-star'></i> Scoring"]\ndirection ${a?"TB":"LR"}\n`;for(var i in e.scoring){var t=e.scoring[i];if(void 0===r||r==i)if(a){n+="Blocking==>",n+=`Attribute${i}\nsubgraph Attribute${i}["<i class='fa fa-star'></i> ${t.id||`Attribute${i}`}"]\ndirection TB\n`;var s=`PARM${i}`;if(t.when)for(var l in t.when){var o=t.when[l];switch(n+=`PARM${i}W${l}{{"<a href='#score${e.scoring.findIndex(e=>e.id==o.ref)}'>\n      <i class='fa fa-star'></i> ${o.ref} ${renderOpCode(o.op)} ${o.value}\n    </a>"}}`,l<t.when.length-1?n+=`--\x3e|"[true]"| PARM${i}W${l+1}\n`:n+=`--\x3e|"[true]"| ${s}\n`,n+=`PARM${i}W${l}--\x3e|"[false]"| `,t.whenNull){case"Zero":case 3:case"Disqualify":case 5:case"Ignore":case 4:n+=`PARMWHENNULL${i}\n`;break;case"NonMatch":case 2:n+=`S${i}NSCORE\n`;break;case"Match":case 1:n+=`S${i}SCORE\n`;break;default:n+=`${s}\n`}}switch(t.whenNull){case"Zero":case 3:n+=`${s}[/"${t.property[0]}"/]--\x3e|"[null]"| PARMWHENNULL${i}(["0.0"])\n`;break;case"Match":case 1:n+=`${s}[/"${t.property[0]}"/]--\x3e|"[null]"| S${i}SCORE\n`;break;case"NonMatch":case 2:n+=`${s}[/"${t.property[0]}"/]--\x3e|"[null]"| S${i}NSCORE\n`;break;case"Disqualify":case 5:n+=`${s}[/"${t.property[0]}"/]--\x3e|"[null]"| PARMWHENNULL${i}[["<i class='fa fa-exclamation'></i> disqualify()"]]\n`;break;case"Ignore":case 4:n+=`${s}[/"${t.property[0]}"/]--\x3e|"[null]"| PARMWHENNULL${i}(["null"])\n`;break;default:s=`${s}[/"${t.property[0]}"/]`}n+=renderAssertionBlock(s,`S${i}`,t.assert),t.partialWeight?n+=`S${i}OUT--\x3e|"[true]"| S${i}SCORE(["${t.matchWeight.toPrecision(2)} * ${t.partialWeight.name}(${t.partialWeight.args.join(",")})"])\n`:n+=`S${i}OUT--\x3e|"[true]"| S${i}SCORE(["${t.matchWeight.toPrecision(2)}"])\n`,n+=`S${i}OUT--\x3e|"[false]"| S${i}NSCORE([${t.nonMatchWeight.toPrecision(2)}])\n`,n+="end\n",n+=`style Attribute${i} fill:#fff,stroke:#000\n`}else n+="Blocking==>",n+=`Attribute${i}[["<i class='fa fa-star'></i> ${t.property[0]}"]]\n`,n+=`Attribute${i}--\x3eSCORE(["<i class='fa fa-calculator'>\n    Sum"])\n`}return n+="end\n"}function renderClassificationSubgraph(e){e.target[0].resource;var a="subgraph Classification[\"<i class='fa fa-random'></i> Classification\"]\ndirection TB\n";return a+="Scoring==>CLASS{{\"<i class='fa fa-random'></i> Classify\"}}\n",a+=`CLASS--\x3e|"[< ${e.nonmatchThreshold}]"| NON["<i class='fa fa-times'></i> Non Match"]\n`,a+=`CLASS--\x3e|"[< ${e.matchThreshold}]"| PROB["<i class='fa fa-question'></i> Probable Match"]\n`,a+=`CLASS--\x3e|"[]> ${e.matchThreshold}]"| MATCH["<i class='fa fa-check'></i> Match"]\n`,a+="style NON fill:#f99,stroke:#900\n",a+="style PROB fill:#ff9,stroke:#990\n",a+="style MATCH fill:#9f9,stroke:#090\n",a+="end\n"}mermaid.mermaidAPI.initialize({theme:"default",flowchartConfig:{width:"100%",htmlLabels:!0,curve:"linear"},securityLevel:"loose",startOnLoad:!0});var graphData="flowchart TB\n";graphData+=renderBlockingSubgraph(configuration),graphData+=renderScoringSubgraph(configuration,!1),graphData+=renderClassificationSubgraph(configuration),graphData+="style Scoring fill:#eff,stroke:#0ff\n",graphData+="style Blocking fill:#efe,stroke:#0f0\n",graphData+="style Classification fill:#fef,stroke:#f0f\n",mermaid.mermaidAPI.render("overallMatchDiv",graphData,e=>document.getElementById("overallMatchSvg").innerHTML=e),graphData="flowchart TB\n",graphData+=renderBlockingSubgraph(configuration,!0),graphData+="style Blocking fill:#efe,stroke:#0f0\n",mermaid.mermaidAPI.render("blockingDiv",graphData,e=>document.getElementById("blockingSvg").innerHTML=e),document.querySelectorAll(".explainsvg").forEach(e=>{var r=e.id.substring(4);a="flowchart LR\n",a+=renderScoringSubgraph(configuration,!0,r-1),a+="Blocking[[\"<i class='fa fa-database'></i> Blocking\"]]--\x3eScoring\n",a+="style Scoring fill:#eff,stroke:#0ff\n",mermaid.mermaidAPI.render(`div_${r}`,a,a=>e.innerHTML=a)});
    ]]>
    </xsl:variable>
    <html>
      <head>
        <title>
          Match Configuration - <xsl:value-of select="@id" />
        </title>
        <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.0/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-PDle/QlgIONtM1aqA2Qemk5gPOE7wFq8+Em+G/hmo5Iq0CCmYZLv3fVRDJ4MMwEA" crossorigin="anonymous" />
        <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous" />
      </head>
      <body class="w-50 m-auto">
        <a name="top" />
        <h1>
          Match Configuration - <xsl:value-of select="@id" />
        </h1>
        <ul>
          <li>
            <a href="#a0">1. Metadata</a>
            <xsl:if test="$m:jsonConfig != null">
              <ul>
                <li>
                  <a href="#a00">1.0. Explain Diagram</a>
                </li>
              </ul>
            </xsl:if>
          </li>
          <li>
            <a href="#a1">2. Blocking</a>
            <ul>
              <xsl:if test="$m:jsonConfig != null">

                <li>
                  <a href="#a10">2.0. Explain Diagram</a>
                </li>
              </xsl:if>
              <xsl:for-each select="m:blocking">
                <li>
                  <a href="#a1{position()}">
                    2.<xsl:value-of select="position()" />. Blocking Instruction <xsl:value-of select="position()" />
                  </a>
                  <ul>
                    <li>
                      <a href="#a1{position()}1">
                        2.<xsl:value-of select="position()" />.1 Summary
                      </a>
                    </li>
                    <li>
                      <a href="#a1{position()}2">
                        2.<xsl:value-of select="position()" />.2 Pseudocode
                      </a>
                    </li>
                  </ul>
                </li>
              </xsl:for-each>
            </ul>
          </li>
          <li>
            <a href="#a2">3. Scoring</a>
            <ul>
              <xsl:for-each select="m:scoring/m:attribute">
                <li>
                  <a href="#a2{position()}">
                    3.<xsl:value-of select="position()" />. <xsl:value-of select="@property" /> <xsl:if test="@id">
                      (<xsl:value-of select="@id" />)
                    </xsl:if>
                  </a>
                  <ul>
                    <xsl:if test="$m:jsonConfig != null">
                      <li>
                        <a href="#a2{position()}0">
                          3.<xsl:value-of select="position()" />.0 Explain Diagram
                        </a>
                      </li>
                    </xsl:if>
                    <li>
                      <a href="#a2{position()}1">
                        3.<xsl:value-of select="position()" />.1 Summary
                      </a>
                    </li>
                    <li>
                      <a href="#a2{position()}2">
                        3.<xsl:value-of select="position()" />.2 Assertions
                      </a>
                    </li>
                    <li>
                      <a href="#a2{position()}3">
                        3.<xsl:value-of select="position()" />.3 Partial Scoring
                      </a>
                    </li>
                    <li>
                      <a href="#a2{position()}4">
                        3.<xsl:value-of select="position()" />.4 Pseudocode
                      </a>
                    </li>
                  </ul>
                </li>
              </xsl:for-each>
            </ul>
          </li>
          <li>
            <a href="#a3">4. Classification</a>
          </li>
        </ul>
        <h2>
          <a name="a0" />1. Metadata
        </h2>
        <table class="table table-striped">
          <tbody>
            <tr>
              <th class="text-right">ID</th>
              <td>
                <xsl:value-of select="@id" />
              </td>
            </tr>
            <tr>
              <th class="text-right">Version</th>
              <td>
                <xsl:value-of select="m:meta/m:version" />
              </td>
            </tr>
            <tr>
              <th class="text-right">Author</th>
              <td>
                <xsl:value-of select="m:meta/m:createdBy" />
              </td>
            </tr>
            <tr>
              <th class="text-right">Created On</th>
              <td>
                <xsl:value-of select="m:meta/m:creationTime" />
              </td>
            </tr>
            <tr>
              <th class="text-right">Status</th>
              <td>
                <xsl:choose>
                  <xsl:when test="m:meta/m:status = 'Active'">
                    <i class="fa fa-check"></i>
                  </xsl:when>
                  <xsl:when test="m:meta/m:status = 'Inactive'">
                    <i class="fa fa-times"></i>
                  </xsl:when>
                  <xsl:when test="m:meta/m:status = 'Obsolete'">
                    <i class="fa fa-trash" />
                  </xsl:when>
                </xsl:choose>
                <xsl:value-of select="m:meta/m:status" />
              </td>
            </tr>
            <tr>
              <th class="text-right">Target(s)</th>
              <td>
                <ul class="m-0">
                  <xsl:for-each select="m:target">
                    <li>
                      <xsl:value-of select="@resource" />
                    </li>
                  </xsl:for-each>
                </ul>
              </td>
            </tr>
            <tr>
              <th align="right">Tags</th>
              <td>
                <ul class="m-0">
                  <xsl:for-each select="m:meta/m:tags/m:add">
                    <li>
                      <strong>
                        <xsl:value-of select="@key" />
                      </strong> =
                      <xsl:value-of select="text()" />
                    </li>
                  </xsl:for-each>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <h3>
          <a name="a00">1.0 Explain Diagram</a>
        </h3>
        <center>
          <div id="overallMatchDiv">-</div>
          <div id="overallMatchSvg">- WAIT -</div>
        </center>
        <h2>
          <a name="a1" />2. Blocking
        </h2>
        <xsl:if test="$m:jsonConfig != null">

          <h3>
            <a name="a10">2.0 Explain Diagram</a>
          </h3>
          <center>
            <div id="blockingDiv">-</div>
            <div id="blockingSvg">- WAIT -</div>
          </center>
        </xsl:if>
        <xsl:apply-templates select="m:blocking" />
        <h2>
          <a name="a2" />3. Scoring
        </h2>
        <xsl:apply-templates select="m:scoring/m:attribute" />

        <h2>
          <a name="a3" />4. Classification
        </h2>
        <div class="container-fluid">

          <div class="row">

            <div class="col alert-danger text-center p-2">
              <span>NON-MATCH</span>
              <span class="h-100 badge badge-danger float-right" style="margin-right:0em;">
                &lt; <xsl:value-of select="@nonmatchThreshold" />
              </span>
            </div>
            <div class="col alert-warning text-center p-2">
              PROBABLE
            </div>
            <div class="col alert-success text-center p-2">
              <span class="h-100 badge badge-success float-left" style="margin-left:0em">
                <xsl:value-of select="@matchThreshold" /> &gt;
              </span>
              <span>MATCH</span>
            </div>
          </div>
        </div>
        <a href="#top">Back to Top</a>

        <xsl:if test="$m:jsonConfig != null">

          <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js">
            <![CDATA[// Mermaid Include]]>
          </script>
          <script type="text/javascript">
            <xsl:value-of disable-output-escaping="yes" select="$mermaidScript"></xsl:value-of>
          </script>
        </xsl:if>
      </body>
    </html>
  </xsl:template>

  <xsl:template match="m:blocking" mode="pseudocode">
    <xsl:variable name="indent" select="'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'" />
    <code class="bg-dark text-light d-block">
      def Block<xsl:value-of select="position() - 1" />($input):<br />
      <xsl:value-of disable-output-escaping="yes" select="$indent" />var $records = [];<br />
      <xsl:for-each select="m:filter">
        <xsl:choose>
          <xsl:when test="@when">
            <xsl:value-of disable-output-escaping="yes" select="$indent" />if (get($input, '<xsl:value-of select="@when" />')) then<br />
            <xsl:value-of disable-output-escaping="yes" select="concat($indent,$indent)" />$records = $records <xsl:choose>
              <xsl:when test="@op = 'or' or position = 1">union with</xsl:when>
              <xsl:otherwise>intersect with</xsl:otherwise>
            </xsl:choose> query(<xsl:value-of select="." />);<br />
            <xsl:value-of disable-output-escaping="yes" select="$indent" />end if;<br />
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of disable-output-escaping="yes" select="concat($indent,$indent)" />$records = $records <xsl:choose>
              <xsl:when test="@op = 'or' or position = 1">union with</xsl:when>
              <xsl:otherwise>intersect with</xsl:otherwise>
            </xsl:choose> query(<xsl:value-of select="." />);<br />
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
      <xsl:value-of disable-output-escaping="yes" select="$indent" />return limit($records, <xsl:value-of select="@maxResults" />);<br />
      end def;<br />
    </code>
  </xsl:template>
  <xsl:template match="m:attribute" mode="pseudocode">
    <xsl:variable name="indent" select="'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'" />
    <code class="bg-dark text-light d-block">
      <xsl:if test="@description">
        // <xsl:value-of select="@description" />
      </xsl:if>
      def <xsl:choose>
        <xsl:when test="@id">
          <xsl:value-of select="@id" />
        </xsl:when>
        <xsl:otherwise>
          Attribute<xsl:value-of select="position() - 1" />
        </xsl:otherwise>
      </xsl:choose>($input, $blocked, $context):<br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" />var $a = get($input, '<xsl:value-of select="translate(@property, ' ', '|')" />');<br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" />var $b = get($blocked, '<xsl:value-of select="translate(@property, ' ', '|')" />');<br />

      <xsl:value-of select="$indent" disable-output-escaping="yes" />if
      <xsl:if test="m:when/m:attribute">
        not(
        <xsl:for-each select="m:when/m:attribute">
          (get_score($context, <xsl:value-of select="@ref" />)
          <xsl:choose>
            <xsl:when test="@op = 'eq'"> == </xsl:when>
            <xsl:when test="@op = 'ne'"> != </xsl:when>
            <xsl:when test="@op = 'lt'"> &lt; </xsl:when>
            <xsl:when test="@op = 'gt'"> &gt; </xsl:when>
            <xsl:when test="@op = 'lte'"> &lt;= </xsl:when>
            <xsl:when test="@op = 'gte'"> &gt;= </xsl:when>
            <xsl:otherwise> &gt; </xsl:otherwise>
          </xsl:choose>
          <xsl:choose>
            <xsl:when test="@value">
              <xsl:value-of select="@value" />
            </xsl:when>
            <xsl:otherwise>0.0</xsl:otherwise>
          </xsl:choose>)
          <xsl:if test="position() != last()"> and </xsl:if>
        </xsl:for-each> ) or
      </xsl:if> ($a == null or $b == null) then <br />
      <xsl:value-of select="concat($indent,$indent)" disable-output-escaping="yes" />return <xsl:value-of select="@whenNull" />(); <br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" />end if;<br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" />var $result = false;<br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" />var $score = 0.0;<br />
      <xsl:apply-templates select="m:assert" mode="pseudocode">
        <xsl:with-param name="indent"  select="$indent" />
      </xsl:apply-templates>
      <br />

      <xsl:value-of select="$indent" disable-output-escaping="yes" />if $result == true then<br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" /><xsl:value-of select="$indent" disable-output-escaping="yes" /> $score = ln(<xsl:value-of select="@m" /> / <xsl:value-of select="@u" />) / ln(2);
      <br /> <xsl:value-of select="$indent" disable-output-escaping="yes" />else <br />
      <xsl:value-of select="$indent" disable-output-escaping="yes" /><xsl:value-of select="$indent" disable-output-escaping="yes" /> $score = ln((1 - <xsl:value-of select="@m" />) / (1 - <xsl:value-of select="@u" />)) / ln(2);
      <br /> <xsl:value-of select="$indent" disable-output-escaping="yes" />end if; <br />

      <xsl:if test="m:partialWeight">
        <xsl:value-of select="$indent" disable-output-escaping="yes" />$score *= fn($a, $b): <br />
        <xsl:apply-templates mode="pseudocode" select="m:partialWeight/m:transform">
          <xsl:with-param name="indent" select="concat($indent, $indent)" />
        </xsl:apply-templates>
        <xsl:value-of select="concat($indent, $indent)" disable-output-escaping="yes" />return <xsl:value-of select="m:partialWeight/@name" />($a,$b)<br />
        <xsl:value-of select="$indent" disable-output-escaping="yes" />end fn;<br />
      </xsl:if>
      <xsl:value-of select="$indent" disable-output-escaping="yes" />return $score;<br />
      end def;<br />
    </code>
  </xsl:template>

  <xsl:template match="m:assert" mode="pseudocode">
    <xsl:param name="indent" />

    <xsl:comment>
      <xsl:value-of select="f:resetMeasured()" />
    </xsl:comment>
    <xsl:apply-templates select="m:transform" mode="pseudocode">
      <xsl:with-param name="indent" select="$indent" />
    </xsl:apply-templates>
    <xsl:choose>
      <xsl:when test="@op = 'and' or @op = 'or'">
        <xsl:for-each select="m:assert">
          <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $result <xsl:value-of select="../@op" /> <br />
          <xsl:value-of disable-output-escaping="yes" select="concat($indent, '&amp;nbsp;&amp;nbsp;&amp;nbsp;')" />fn ($a, $b):<br />
          <xsl:apply-templates select="." mode="pseudocode">
            <xsl:with-param name="indent" select="concat($indent, '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;')" />
          </xsl:apply-templates>
          <xsl:value-of disable-output-escaping="yes" select="concat($indent, '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;')" />return $result;<br />
          <xsl:value-of disable-output-escaping="yes" select="concat($indent, '&amp;nbsp;&amp;nbsp;&amp;nbsp;')" />end fn;<br />
        </xsl:for-each>
      </xsl:when>

      <xsl:when test="@op = 'eq' and not(@value)">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $a == $b;<br />
      </xsl:when>
      <xsl:when test="@op = 'ne' and not(@value)">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $a != $b) then<br />
      </xsl:when>
      <xsl:when test="@op = 'eq'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $measure == <xsl:value-of select="@value" /><br />
      </xsl:when>
      <xsl:when test="@op = 'ne'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $resut = $measure != <xsl:value-of select="@value" /><br />
      </xsl:when>
      <xsl:when test="@op = 'lt'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $measure &lt; <xsl:value-of select="@value" /><br />
      </xsl:when>
      <xsl:when test="@op = 'gt'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $measure &gt; <xsl:value-of select="@value" /><br />
      </xsl:when>
      <xsl:when test="@op = 'lte'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $measure &lt;= <xsl:value-of select="@value" /><br />
      </xsl:when>
      <xsl:when test="@op = 'gte'">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $result = $measure &gt;= <xsl:value-of select="@value" /><br />
      </xsl:when>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="m:string" mode="argument">
    , "<xsl:value-of select="." />"
  </xsl:template>
  <xsl:template match="*" mode="argument">
    , <xsl:value-of select="." />
  </xsl:template>
  <xsl:template match="m:transform" mode="pseudocode">
    <xsl:param name="indent" />
    <xsl:choose>
      <xsl:when test="position() != last() or not(../@value)">
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $a = <xsl:value-of select="@name" />($a<xsl:apply-templates select="m:args/*" mode="argument" />);<br />
        <xsl:value-of disable-output-escaping="yes" select="$indent" />set $b = <xsl:value-of select="@name" />($b<xsl:apply-templates select="m:args/*" mode="argument" />);
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of disable-output-escaping="yes" select="$indent" />
        <xsl:choose>
          <xsl:when test="not(f:getMeasured())">
            <xsl:comment>
              <xsl:value-of select="f:setMeasured()" />
            </xsl:comment>
            var $measure = <xsl:value-of select="@name" />($a, $b<xsl:apply-templates select="m:args/*" mode="argument" />);
          </xsl:when>
          <xsl:otherwise>
            set $measure = <xsl:value-of select="@name" />($measure<xsl:apply-templates select="m:args/*" mode="argument" />);
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
    <br />
  </xsl:template>

  <xsl:template match="m:attribute">
    <h3>
      <a name="score_{@id}" />
      <a name="a2{position()}" />
      <a name="score{position() - 1}" />
      3.<xsl:value-of select="position()" />. <xsl:choose>
        <xsl:when test="@id">
          <xsl:value-of select="@id" />
        </xsl:when>
        <xsl:otherwise>
          Attribute<xsl:value-of select="position() - 1" />
        </xsl:otherwise>
      </xsl:choose> (<xsl:value-of select="@property" />)
    </h3>
    <xsl:if test="$m:jsonConfig != null">

      <h4>
        <a name="a2{position()}0" />

        3.<xsl:value-of select="position()" />.0. Explain Diagram
      </h4>
      <center>
        <div id="div_{position()}" class="explainDiv">-</div>
        <div id="svg_{position()}" class="explainSvg">-</div>
      </center>
    </xsl:if>
    <h4>
      <a name="a2{position()}1" />

      3.<xsl:value-of select="position()" />.1. Summary
    </h4>

    <table class="table table-border">
      <thead>
        <tr>
          <th>
            Property Path
          </th>
          <td>
            <code>
              <xsl:value-of select="translate(@property, ' ', '|')" />
            </code>
          </td>
        </tr>

        <tr>
          <th>
            When Null
          </th>
          <td>
            <xsl:choose>
              <xsl:when test="@whenNull = 'zero'">Score as 0</xsl:when>
              <xsl:when test="@whenNull = 'none'">Take no action</xsl:when>
              <xsl:when test="@whenNull = 'match'">Score as match</xsl:when>
              <xsl:when test="@whenNull = 'nonmatch'">Score as non-match</xsl:when>
              <xsl:when test="@whenNull = 'ignore'">Ignore attribute (reducing total possible score)</xsl:when>
              <xsl:when test="@whenNull = 'disqualify'">Disqualify the candidate</xsl:when>
            </xsl:choose>
          </td>
        </tr>

        <tr>
          <th>
            M
          </th>
          <td>
            <xsl:value-of select="@m" />
          </td>
        </tr>

        <tr>
          <th >U</th>
          <td>
            <xsl:value-of select="@u" />
          </td>
        </tr>

        <xsl:if test="m:when/m:attribute">
          <tr>
            <th>Depends On:</th>
            <td>
              <table>

                <xsl:for-each select="m:when/m:attribute">
                  <tr>
                    <td>
                      <a href="#score_{@ref}">
                        <xsl:value-of select="@ref" />
                      </a>
                    </td>
                    <td>
                      <xsl:call-template name="pretty-operator">
                        <xsl:with-param name="op" select="@op" />
                      </xsl:call-template>
                    </td>
                    <td>
                      <xsl:value-of select="@value" />
                    </td>
                  </tr>
                </xsl:for-each>
              </table>
            </td>
          </tr>
        </xsl:if>
      </thead>
    </table>

    <a href="#top">Back to Top</a>

    <h4>
      <a name="a2{position()}2" />

      3.<xsl:value-of select="position()" />.2. Assertions
    </h4>
    <p>This section illustrates the assertions which are executed and evaluated against the values in A and B to obtain a score.</p>
    <xsl:apply-templates select="m:assert" mode="table" />

    <a href="#top">Back to Top</a>

    <h4>
      <a name="a2{position()}3" />

      3.<xsl:value-of select="position()" />.3. Partial Scoring
    </h4>

    <xsl:choose>
      <xsl:when test="m:partialWeight">
        <p>
          This attribute has a partial weight configured. This partial weight is used to indicate how the score of this attribute should be modified when the assertions
          agree, however the exact value of A and B are not the same.
        </p>
        <xsl:apply-templates select="m:partialWeight" mode="table" />
      </xsl:when>
    </xsl:choose>
    <a href="#top">Back to Top</a>

    <h4>
      <a name="a2{position()}4" />

      3.<xsl:value-of select="position()" />.5. Pseudocode
    </h4>

    <p>
      The following pseudocode is generated in a language-neutral manner and is itended to illustrate how the process of scoring this attribute will
      occur.
    </p>
    <xsl:apply-templates select="." mode="pseudocode" />
    <a href="#top">Back to Top</a>
  </xsl:template>

  <xsl:template match="m:assert|m:partialWeight" mode="table">
    <xsl:choose>
      <xsl:when test="@op = 'or' or @op = 'and'">
        <table class="table table-striped">
          <tr>
            <th>
              <xsl:call-template name="pretty-operator">
                <xsl:with-param name="op" select="@op" />
              </xsl:call-template>
            </th>
            <td>
              <xsl:apply-templates select="m:assert" mode="table" />
            </td>
          </tr>
        </table>
      </xsl:when>
      <xsl:when test="(@op = 'eq' or @op = 'ne') and not(@value)">
        <table class="table table-striped">
          <xsl:if test="m:transform">
            <tr>
              <th>Transform</th>
              <td>
                <table class="table">
                  <thead>
                    <tr>
                      <th>Transform</th>
                      <th>Arguments</th>
                    </tr>
                  </thead>
                  <tbody>
                    <xsl:apply-templates mode="table" select="m:transform" />
                  </tbody>
                </table>
              </td>
            </tr>
          </xsl:if>
          <tr>
            <th>Assert</th>
            <td>
              A <xsl:call-template name="pretty-operator">
                <xsl:with-param name="op" select="@op"></xsl:with-param>
              </xsl:call-template>
              B
            </td>
          </tr>
        </table>
      </xsl:when>
      <xsl:otherwise>
        <table class="table">
          <xsl:if test="m:transform">
            <tr>
              <th>Transform</th>
              <td>
                <table class="match-attribute-summary-transform">
                  <thead>
                    <tr>
                      <th>Transform</th>
                      <th>Arguments</th>
                    </tr>
                  </thead>
                  <tbody>
                    <xsl:apply-templates mode="table" select="m:transform" />
                  </tbody>
                </table>
              </td>
            </tr>
          </xsl:if>
          <xsl:if test="@op">
            <tr>
              <th>Assert</th>
              <td>
                result <xsl:call-template name="pretty-operator">
                  <xsl:with-param name="op" select="@op"></xsl:with-param>
                </xsl:call-template> <xsl:value-of select="@value" />
              </td>
            </tr>
          </xsl:if>
          <xsl:if test="@name">
            <tr>
              <th>Algorithm</th>
              <td>

                <xsl:value-of select="@name" />
              </td>
            </tr>
          </xsl:if>
        </table>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="m:transform" mode="table">
    <tr>
      <td>
        <xsl:value-of select="@name" />
      </td>
      <td>
        <ul class="m-0">
          <xsl:for-each select="m:args/*">
            <li>
              <xsl:value-of select="." />
            </li>
          </xsl:for-each>
        </ul>
      </td>
    </tr>
    <xsl:if test="position() != last()">
      <tr>
        <td colspan="2" class="text-center alert-primary">THEN</td>
      </tr>
    </xsl:if>
  </xsl:template>
  <xsl:template match="m:blocking">
    <h3>
      <a name="a1{position()}" />

      2.<xsl:value-of select="position()" />. Blocking Instruction <xsl:value-of select="position() - 1" />
    </h3>
    <h4>
      <a name="a1{position()}1" />

      2.<xsl:value-of select="position()" />.1. Summary
    </h4>
    <table class="table table-striped">
      <thead>
        <tr>
          <th>When</th>
          <th>Query For</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <xsl:for-each select="m:filter">
          <tr>
            <td>
              <code>
                <xsl:value-of select="@when" />
              </code>
            </td>
            <td>
              <code>
                <xsl:value-of select="text()" />
              </code>
            </td>
            <td>
              <xsl:if test="position() != last()">
                <xsl:value-of select="../@op" />
              </xsl:if>
            </td>
          </tr>
        </xsl:for-each>
      </tbody>
    </table>
    <a href="#top">Back to Top</a>

    <h4>
      <a name="a1{position()}2" />

      2.<xsl:value-of select="position()" />.2. Pseudocode
    </h4>
    <xsl:apply-templates select="." mode="pseudocode" />
    <a href="#top">Back to Top</a>
  </xsl:template>

  <xsl:template name="pretty-operator">
    <xsl:param name="op" />
    <span class="badge badge-info">

      <xsl:choose>
        <xsl:when test="$op = 'eq'"> equal </xsl:when>
        <xsl:when test="$op = 'ne'"> not-equal </xsl:when>
        <xsl:when test="$op = 'gte'"> greater-than-or-equal </xsl:when>
        <xsl:when test="$op = 'gt'"> greater-than </xsl:when>
        <xsl:when test="$op = 'lte'"> less-than-or-equal </xsl:when>
        <xsl:when test="$op = 'le'"> less-than </xsl:when>
        <xsl:when test="$op = 'and'">intersect</xsl:when>
        <xsl:when test="$op = 'or'">union</xsl:when>
      </xsl:choose>
    </span>
  </xsl:template>
</xsl:stylesheet>